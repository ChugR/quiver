#!/usr/bin/python
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals
from __future__ import with_statement

import argparse
import os
import signal
import sys
import traceback

home = os.path.normpath("@quiver_home@")
sys.path.insert(0, os.path.join(home, "python"))

from plano import *
from quiver import _quiver_arrow_impls_by_name

def run_test(sender_impl, receiver_impl, server_impl, peer_to_peer, failures):
    if peer_to_peer:
        summary = "{} -> {} ".format(sender_impl, receiver_impl)
    else:
        summary = "{} -> server -> {} ".format(sender_impl, receiver_impl)

    print("{:.<73} ".format(summary), end="")

    flush()

    address = "//127.0.0.1:{}/q0".format(random_port())
    server_command = "quiver-server {} --impl {} --verbose".format(address, server_impl)
    server = None
    test_output_file = make_temp_file()
    test_command = build_test_command(address, sender_impl, receiver_impl, peer_to_peer)

    with open(test_output_file, "w") as f:
        try:
            if not peer_to_peer:
                server = start_process(server_command, stdout=f, stderr=f)

                def signal_handler(signum, frame):
                    stop_process(server)
                    exit()

                signal.signal(signal.SIGTERM, signal_handler)

                sleep(1) # XXX Ugh

            call(test_command, stdout=f, stderr=f)

            print("PASSED")
        except KeyboardInterrupt:
            raise
        except CalledProcessError as e:
            failures.append(str(e))

            print("FAILED")

            with open(test_output_file, "r") as f:
                for line in f:
                    print("> {}".format(line), end="")
        except:
            traceback.print_exc()
        finally:
            if server is not None:
                stop_process(server)

    flush()

def build_test_command(address, sender_impl, receiver_impl, peer_to_peer):
    command = [
        "quiver-launch", address,
        "--sender-impl", sender_impl,
        "--receiver-impl", receiver_impl,
        "--messages", "1k",
        "--verbose",
    ]

    if peer_to_peer:
        command += ["--receiver-options", "'--server --passive'"]

    return " ".join(command)

def main():
    set_message_threshold("warn")

    parser = argparse.ArgumentParser()

    parser.add_argument("--sender-impl", metavar="IMPL", default=None,
                        help="Test only sender IMPL")
    parser.add_argument("--receiver-impl", metavar="IMPL", default=None,
                        help="Test only receiver IMPL")
    parser.add_argument("--server-impl", metavar="IMPL", default="builtin",
                        help="Test using server IMPL")
    parser.add_argument("--client-server", action="store_true",
                        help="Test only client-server mode")
    parser.add_argument("--peer-to-peer", action="store_true",
                        help="Test only peer-to-peer mode")
    parser.add_argument("--init-only", action="store_true",
                        help="Initialize and immediately exit")

    args = parser.parse_args()

    sender_impls = [
        "qpid-jms",
        "qpid-messaging-cpp",
        "qpid-messaging-python",
        "qpid-proton-python",
        "rhea",
        "vertx-proton",
    ]

    receiver_impls = [
        "qpid-jms",
        "qpid-messaging-cpp",
        "qpid-messaging-python",
        "qpid-proton-python",
        "rhea",
        "vertx-proton",
    ]

    peer_to_peer_impls = {
        "qpid-proton-python",
        "rhea",
    }

    if exists(join(home, "exec", "quiver-arrow-qpid-proton-cpp")):
        sender_impls.append("qpid-proton-cpp")
        receiver_impls.append("qpid-proton-cpp")
        peer_to_peer_impls.add("qpid-proton-cpp")

    if args.sender_impl is not None:
        try:
            sender_impls = [_quiver_arrow_impls_by_name[args.sender_impl]]
        except KeyError:
            exit("Implementation '{}' is unknown", args.sender_impl)

    if args.receiver_impl is not None:
        try:
            receiver_impls = [_quiver_arrow_impls_by_name[args.receiver_impl]]
        except KeyError:
            exit("Implementation '{}' is unknown", args.receiver_impl)

    server_impl = args.server_impl

    client_server = True
    peer_to_peer = True

    if args.client_server:
        peer_to_peer = False

    if args.peer_to_peer:
        client_server = False

    if args.init_only:
        return

    failures = list()

    if client_server:
        print("# Testing client-server send and receive with server '{}'".format(server_impl))

        for sender_impl in sorted(sender_impls):
            for receiver_impl in receiver_impls:
                run_test(sender_impl, receiver_impl, server_impl, False, failures)

    if peer_to_peer:
        print("# Testing peer-to-peer send and receive")

        for sender_impl in sorted(sender_impls):
            for receiver_impl in receiver_impls:
                if receiver_impl not in peer_to_peer_impls:
                    continue

                run_test(sender_impl, receiver_impl, server_impl, True, failures)

    print("# Test failures: {}".format(len(failures)))

    for failure in failures:
        print(failure) # Need summary

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass
