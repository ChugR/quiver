#!/usr/bin/python
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals
from __future__ import with_statement

import argparse
import os
import sys
import time
import tempfile
import traceback

home = os.path.normpath("@quiver_home@")
sys.path.insert(0, os.path.join(home, "python"))

from plano import *
from quiver import *

def run_test(sender_impl, receiver_impl, server_impl, output_dir, failures):
    if server_impl is None:
        summary = "{} -> {} ".format(sender_impl, receiver_impl)
        test_dir = join(output_dir, sender_impl, receiver_impl, "peer-to-peer")
    else:
        summary = "{} -> {} -> {} ".format(sender_impl, server_impl, receiver_impl)
        test_dir = join(output_dir, sender_impl, receiver_impl, server_impl)

    print("{:.<113} ".format(summary), end="")

    flush()

    test_data_dir = join(test_dir, "data")
    test_output_file = join(test_dir, "output.txt")
    test_status_file = join(test_dir, "status.txt")

    # XXX arrayify

    test_command = "quiver //127.0.0.1/q0 -m 100 --sender {} --receiver {} --output {}".format \
                   (sender_impl, receiver_impl, test_data_dir)

    if server_impl is None:
        test_command = "{} --peer-to-peer".format(test_command)

    server = None
    server_output_file = join(test_dir, "server-output.txt")
    server_ready_file = make_temp_file()
    server_command = "quiver-server //127.0.0.1/q0 --impl {} --ready-file {} --verbose".format \
                         (server_impl, server_ready_file)

    make_dir(test_dir)

    with open(server_output_file, "w") as sf:
        with open(test_output_file, "w") as tf:
            try:
                if server_impl is not None:
                    server = start_process(server_command, stdout=sf, stderr=sf)

                    for i in range(30):
                        if read(server_ready_file) == "ready\n":
                            break

                        sleep(1)
                    else:
                        raise Timeout("Timed out waiting for server to be ready")

                call(test_command, stdout=tf, stderr=tf)

                write(test_status_file, "PASSED")
            except KeyboardInterrupt:
                raise
            except (CalledProcessError, Timeout) as e:
                failures.append(str(e))

                write(test_status_file, "FAILED: {}".format(str(e)))

                # XXX Record the result in this format

                print("FAILED")
                print("--- Error message ---")
                print("> {}".format(str(e)))
                print("--- Test command ---")
                print("> {}".format(test_command))
                print("--- Test output ---")

                for line in read_lines(test_output_file):
                    print("> {}".format(line), end="")

                if server_impl is not None:
                    print("--- Server command ---")
                    print("> {}".format(server_command))
                    print("--- Server output ---")

                    for line in read_lines(server_output_file):
                        print("> {}".format(line), end="")
            except:
                traceback.print_exc()
            finally:
                if server is not None:
                    stop_process(server)

    flush()

class Timeout(Exception):
    pass

def main():
    set_message_threshold("warn")

    parser = argparse.ArgumentParser()

    parser.add_argument("--senders", metavar="IMPLS", default=None,
                        help="Test only senders in IMPLS")
    parser.add_argument("--receivers", metavar="IMPLS", default=None,
                        help="Test only receivers in IMPLS")
    parser.add_argument("--servers", metavar="IMPLS", default=None,
                        help="Test only servers in IMPLS")
    parser.add_argument("--client-server", action="store_true",
                        help="Test only client-server mode")
    parser.add_argument("--peer-to-peer", action="store_true",
                        help="Test only peer-to-peer mode")
    parser.add_argument("--init-only", action="store_true",
                        help="Initialize and immediately exit")

    args = parser.parse_args()

    sender_impls = list(ARROW_IMPLS)
    receiver_impls = list(ARROW_IMPLS)
    server_impls = list(SERVER_IMPLS)

    client_server = True
    peer_to_peer = True

    if args.client_server:
        peer_to_peer = False

    if args.peer_to_peer:
        client_server = False

    if args.init_only:
        return

    script = file_name(ARGS[0])
    timestamp = time.strftime('%Y-%m-%d', time.localtime())
    output_dir = "{}-{}".format(script, timestamp)

    remove(output_dir)
    make_dir(output_dir)

    failures = list()

    if client_server:
        for sender_impl in sender_impls:
            for receiver_impl in receiver_impls:
                for server_impl in server_impls:
                    if "activemq-artemis-jms" in (sender_impl, receiver_impl):
                        if server_impl != "activemq-artemis":
                            continue

                    if "activemq-jms" in (sender_impl, receiver_impl):
                        if server_impl not in ("activemq", "activemq-artemis"):
                            continue

                    run_test(sender_impl, receiver_impl, server_impl, output_dir, failures)

    if peer_to_peer:
        for sender_impl in sender_impls:
            if sender_impl in ("activemq-jms", "activemq-artemis-jms"):
                continue

            for receiver_impl in receiver_impls:
                if receiver_impl not in PEER_TO_PEER_ARROW_IMPLS:
                    continue

                run_test(sender_impl, receiver_impl, None, output_dir, failures)

    print("Test failures: {}".format(len(failures)))

    for failure in failures:
        print(failure) # Need summary

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass
