#!/usr/bin/python
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#

from __future__ import print_function

import os
import sys

default = os.path.normpath("@quiver_home@")
home = os.environ.get("QUIVER_HOME", default)

sys.path.insert(0, os.path.join(home, "python"))

import argparse
import subprocess
import uuid

def main():
    description = "Test the performance of AMQP messaging APIs"
    epilog = "operations:\n" \
             "  send                  Send messages\n" \
             "  receive               Receive messages\n" \
             "\n" \
             "URLs:\n" \
             "  [HOST:PORT]/ADDRESS\n" \
             "  example.com/jobs\n" \
             "  example.com:5672/jobs\n" \
             "  10.0.0.101/jobs\n" \
             "  localhost:56720/q0\n" \
             "  q0\n" \
             "\n" \
             "implementations:\n" \
             "  proton-python\n" \
             "  qpid-messaging-python       Supports client mode only\n" \
             "\n" \
             "example usage:\n" \
             "  $ qdrouterd &               # Start an AMQP server\n" \
             "  $ quiver receive q0 &       # Start receiving\n" \
             "  $ quiver send q0            # Start sending\n" \
             "\n" \

    class Formatter(argparse.ArgumentDefaultsHelpFormatter,
                    argparse.RawDescriptionHelpFormatter):
        pass

    parser = argparse.ArgumentParser(description=description,
                                     epilog=epilog,
                                     formatter_class=Formatter)

    parser.add_argument("operation", metavar="OPERATION",
                        choices=["send", "receive"],
                        help="Either 'send' or 'receive'")
    parser.add_argument("url", metavar="URL",
                        help="The location of an AMQP node")
    parser.add_argument("--impl", metavar="NAME",
                        help="Use the NAME implementation",
                        default="proton-python")
    parser.add_argument("-n", "--transfers", metavar="COUNT",
                        help="Send or receive COUNT messages",
                        default=100000, type=int)
    parser.add_argument("--connections", metavar="COUNT",
                        help="Create COUNT connections", default=1, type=int)
    parser.add_argument("--sessions", metavar="COUNT",
                        help="Create COUNT sessions", default=1, type=int)
    parser.add_argument("--links", metavar="COUNT",
                        help="Create COUNT links", default=1, type=int)
    parser.add_argument("--server", action="store_true",
                        help="Operate in server mode")
    parser.add_argument("--ready-file", metavar="FILE",
                        help="Create FILE when the server is listening")
    #parser.add_argument("-m", "--message")
    
    args = parser.parse_args()

    mode = "client"
    operation = args.operation
    transfers = str(args.transfers)
    connections = args.connections
    sessions = max(args.sessions, connections)
    links = max(args.links, sessions)
    ready_file = args.ready_file
    results_file = "/tmp/quiver-{}.csv".format(uuid.uuid4())

    if args.server:
        mode = "server"

    if "/" in args.url:
        host_port, address = args.url.split("/", 1)
    else:
        host_port, address = "localhost:5672", args.url
    
    libexec_dir = os.path.normpath("{}/../../libexec/quiver".format(home))
    executable = "{}/quiver-{}".format(libexec_dir, args.impl)

    if not os.path.exists(executable):
        exit("Error: Can't find '{}'".format(executable))
    
    command = [
        executable,
        mode,
        operation,
        host_port,
        address,
        transfers,
    ]

    if mode == "client":
        command += [
            "connections={}".format(connections),
            "sessions={}".format(sessions),
            "links={}".format(links),
        ]

    if operation == "receive":
        command += [
            "results-file={}".format(results_file),
        ]

    if ready_file is not None:
        command += [
            "ready-file={}".format(ready_file),
        ]

    print("Calling '{}'".format(" ".join(command)))

    subprocess.check_call(command)

    if args.operation == "receive":
        send_times = list()
        receive_times = list()
        latencies = list()
        
        with open(results_file, "r") as f:
            for line in f:
                message_id, send_time, receive_time = line.split(",", 2)

                send_time = float(send_time)
                receive_time = float(receive_time)
                latency = receive_time - send_time

                send_times.append(send_time)
                receive_times.append(receive_time)
                latencies.append(latency)

        duration = max(receive_times) - min(send_times)
        transfer_count = len(receive_times)
        transfer_rate = int(round(transfer_count / duration))
        max_latency = int(round(max(latencies) * 1000))
                
        print("-" * 80)
        print("{:16}  {:8.1f} s".format("Duration:", duration))
        print("{:16}  {:8,} transfers".format("Transfer count:", transfer_count))
        print("{:16}  {:8,} transfers/s".format("Transfer rate:", transfer_rate))
        print("{:16}  {:8,} ms".format("Max latency:", max_latency))
        print("-" * 80)

        os.remove(results_file)
        
if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass
