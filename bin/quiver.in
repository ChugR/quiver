#!/usr/bin/python
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals
from __future__ import with_statement

import os
import sys

default = os.path.normpath("@quiver_home@")
home = os.environ.get("QUIVER_HOME", default)

sys.path.insert(0, os.path.join(home, "python"))

import argparse
import shutil
import subprocess
import tempfile
import time

def main():
    description = "Test the performance of AMQP servers and messaging APIs"
    epilog = "operations:\n" \
             "  send                  Send messages\n" \
             "  receive               Receive messages\n" \
             "\n" \
             "addresses:\n" \
             "  [//DOMAIN/]PATH              The default domain is 'localhost:5672'\n" \
             "  //example.net/jobs\n" \
             "  //10.0.0.10:5672/jobs/alpha\n" \
             "  //localhost/q0\n" \
             "  q0\n" \
             "\n" \
             "implementations:\n" \
             "  proton-python\n" \
             "  qpid-messaging-python        Supports client mode only\n" \
             "\n" \
             "example usage:\n" \
             "  $ qdrouterd &                # Start an AMQP server\n" \
             "  $ quiver receive q0 &        # Start receiving\n" \
             "  $ quiver send q0             # Start sending\n" \
             "\n" \

    class Formatter(argparse.ArgumentDefaultsHelpFormatter,
                    argparse.RawDescriptionHelpFormatter):
        pass

    parser = argparse.ArgumentParser(description=description,
                                     epilog=epilog,
                                     formatter_class=Formatter)

    parser.add_argument("operation", metavar="OPERATION",
                        choices=["send", "receive"],
                        help="Either 'send' or 'receive'")
    parser.add_argument("address", metavar="ADDRESS",
                        help="The location of an AMQP node")
    parser.add_argument("-n", "--messages", metavar="COUNT",
                        help="Send or receive COUNT messages",
                        default=100000, type=int)
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="Periodically print status to the console")
    parser.add_argument("--impl", metavar="NAME",
                        help="Use NAME implementation",
                        default="proton-python")
    parser.add_argument("--bytes", metavar="COUNT",
                        help="Send message bodies containing COUNT bytes",
                        default=1000, type=int)
    parser.add_argument("--credit", metavar="COUNT",
                        help="Sustain credit for COUNT incoming transfers",
                        default=100, type=int)
    parser.add_argument("--timeout", metavar="SECONDS",
                        help="Fail after SECONDS without transfers",
                        default=10, type=int)
    parser.add_argument("--server", action="store_true",
                        help="Operate in server mode")
    parser.add_argument("--output", metavar="DIRECTORY",
                        help="Save output files to DIRECTORY")
    parser.add_argument("--quiet", action="store_true",
                        help="Print nothing to the console")
    
    args = parser.parse_args()

    impl = os.path.join(home, "quiver-{}".format(args.impl))

    if not os.path.exists(impl):
        exit("Error: Can't find '{}'".format(impl))
    
    output_dir = args.output
    mode = "client"
    operation = args.operation
    messages = str(args.messages)
    bytes_ = str(args.bytes)
    credit = str(args.credit)
    timeout = str(args.timeout)

    if output_dir is None:
        output_dir = tempfile.mkdtemp(prefix="quiver-")

    if args.server:
        mode = "server"
        
    if args.address.startswith("//"):
        domain, path = args.address[2:].split("/", 1)
    else:
        domain, path = "localhost:5672", args.address
    
    command = [
        impl,
        output_dir,
        mode,
        operation,
        domain,
        path,
        messages,
        bytes_,
        credit,
        timeout,
    ]

    print("Calling '{}'".format(" ".join(command)))

    transfers_file = os.path.join(output_dir, "transfers.csv")
    
    with open(transfers_file, "w") as f:
        start_time = time.time()

        proc = subprocess.Popen(command, stdout=f)
        proc.wait()

        stop_time = time.time()

    duration = stop_time - start_time

    if operation == "receive":
        report(transfers_file)

    # shutil.rmtree(output_dir)
        
def report(transfers_file):
    if os.path.getsize(transfers_file) == 0:
        exit("Error: No transfers")
    
    send_times = list()
    receive_times = list()
    latencies = list()

    with open(transfers_file, "r") as f:
        for line in f:
            message_id, send_time, receive_time = line.split(",", 2)

            send_time = float(send_time)
            receive_time = float(receive_time)
            latency = receive_time - send_time

            send_times.append(send_time)
            receive_times.append(receive_time)
            latencies.append(latency)

    duration = max(receive_times) - min(send_times)
    transfer_count = len(receive_times)
    transfer_rate = int(round(transfer_count / duration))
    latency_avg = sum(latencies) / transfer_count * 1000
    latency_min = min(latencies) * 1000
    latency_max = max(latencies) * 1000
    latency = "{:.1f}, {:.1f}, {:.1f}".format(latency_min, latency_max,
                                              latency_avg)
            
    print("-" * 80)
    print("{:32} {:24.1f} s".format("Duration:", duration))
    print("{:32} {:24,} transfers".format("Transfer count:", transfer_count))
    print("{:32} {:24,} transfers/s".format("Transfer rate:", transfer_rate))
    print("{:32} {:>24} ms".format("Latency (min, max, avg):", latency))
    print("-" * 80)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass
