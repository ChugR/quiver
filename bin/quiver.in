#!/usr/bin/python
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#

from __future__ import print_function

import os
import sys
import uuid

default = os.path.normpath("@quiver_home@")
home = os.environ.get("QUIVER_HOME", default)

sys.path.insert(0, os.path.join(home, "python"))

from argparse import ArgumentParser
from argparse import RawDescriptionHelpFormatter
from subprocess import check_call

def main():
    description = "A tool for testing the performance of " \
                  "AMQP messaging APIs"

    epilog = "operations:\n" \
             "  send                 Send messages\n" \
             "  receive              Receive messages\n" \
             "\n" \
             "implementations:\n" \
             "  proton-python\n" \
             "\n" \
             "typical usage:\n" \
             "  $ qdrouterd &\n" \
             "  $ quiver receive q0 &\n" \
             "  $ quiver send q0\n" \
             "\n" \

    parser = ArgumentParser(description=description, epilog=epilog,
                            formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument("operation", metavar="OPERATION",
                        choices=["send", "receive"],
                        help="Either 'send' or 'receive'")
    parser.add_argument("address", metavar="ADDRESS",
                        help="The address of an AMQP node")
    parser.add_argument("--server", action="store_true",
                        help="Accept incoming connections")
    parser.add_argument("--impl", metavar="IMPLEMENTATION",
                        help="Use IMPLEMENTATION", default="proton-python")
    parser.add_argument("--connections", metavar="COUNT",
                        help="Use COUNT connections", default=1, type=int)
    parser.add_argument("--sessions", metavar="COUNT",
                        help="Use COUNT sessions", default=1, type=int)
    parser.add_argument("--links", metavar="COUNT",
                        help="Use COUNT links", default=1, type=int)
    parser.add_argument("-t", "--transfers", metavar="COUNT",
                        help="Send or receive COUNT messages",
                        default=10000, type=int)
    #parser.add_argument("-m", "--message")
    
    args = parser.parse_args()

    mode = "client"
    operation = args.operation
    address = args.address
    transfers = str(args.transfers)
    connections = args.connections
    sessions = max(args.sessions, connections)
    links = max(args.links, sessions)
    results_file = "/tmp/quiver-{}.csv".format(uuid.uuid4())

    if args.server:
        mode = "server"
    
    if "/" not in address:
        address = "localhost:5672/{}".format(address)
    
    libexec_dir = os.path.normpath("{}/../../libexec/quiver".format(home))
    executable = "{}/quiver-{}".format(libexec_dir, args.impl)

    if not os.path.exists(executable):
        exit("Error: Can't find '{}'".format(executable))
    
    command = [
        executable,
        mode,
        operation,
        address,
        transfers,
    ]

    if mode == "client":
        command += [
            "connections={}".format(connections),
            "sessions={}".format(sessions),
            "links={}".format(links),
        ]

    if operation == "receive":
        command += [
            "results-file={}".format(results_file),
        ]

    print("Calling '{}'".format(" ".join(command)))

    check_call(command)

    if args.operation == "receive":
        send_times = list()
        receive_times = list()
        latencies = list()
        
        with open(results_file, "r") as f:
            for line in f:
                message_id, send_time, receive_time = line.split(",", 2)

                send_time = float(send_time)
                receive_time = float(receive_time)
                latency = receive_time - send_time

                send_times.append(send_time)
                receive_times.append(receive_time)
                latencies.append(latency)

        duration = max(*receive_times) - min(*send_times)
        transfer_count = len(receive_times)
        transfer_rate = int(round(transfer_count / duration))
        max_latency = int(round(max(*latencies) * 1000))
                
        print("-" * 80)
        print("{:16}  {:8.1f} s".format("Duration:", duration))
        print("{:16}  {:8,} transfers".format("Transfer count:", transfer_count))
        print("{:16}  {:8,} transfers/s".format("Transfer rate:", transfer_rate))
        print("{:16}  {:8,} ms".format("Max latency:", max_latency))
        print("-" * 80)

        os.remove(results_file)
        
if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass
