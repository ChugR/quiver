#!/usr/bin/python
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals
from __future__ import with_statement

import os
import sys

default = os.path.normpath("@quiver_home@")
home = os.environ.get("QUIVER_HOME", default)

sys.path.insert(0, os.path.join(home, "python"))

import argparse
import shutil
import subprocess
import tempfile

def main():
    description = "Test the performance of AMQP servers and messaging APIs"
    epilog = "operations:\n" \
             "  send                  Send messages\n" \
             "  receive               Receive messages\n" \
             "\n" \
             "URLs:\n" \
             "  [HOST:PORT]/ADDRESS\n" \
             "  example.com/jobs\n" \
             "  example.com:5672/jobs\n" \
             "  10.0.0.101/jobs\n" \
             "  localhost:56720/q0\n" \
             "  q0\n" \
             "\n" \
             "implementations:\n" \
             "  proton-python\n" \
             "  qpid-messaging-python       Supports client mode only\n" \
             "\n" \
             "example usage:\n" \
             "  $ qdrouterd &               # Start an AMQP server\n" \
             "  $ quiver receive q0 &       # Start receiving\n" \
             "  $ quiver send q0            # Start sending\n" \
             "\n" \

    class Formatter(argparse.ArgumentDefaultsHelpFormatter,
                    argparse.RawDescriptionHelpFormatter):
        pass

    parser = argparse.ArgumentParser(description=description,
                                     epilog=epilog,
                                     formatter_class=Formatter)

    parser.add_argument("operation", metavar="OPERATION",
                        choices=["send", "receive"],
                        help="Either 'send' or 'receive'")
    parser.add_argument("url", metavar="URL",
                        help="The location of an AMQP node")
    parser.add_argument("--impl", metavar="NAME",
                        help="Use the NAME implementation",
                        default="proton-python")
    parser.add_argument("-n", "--transfers", metavar="COUNT",
                        help="Send or receive COUNT messages",
                        default=100000, type=int)
    parser.add_argument("--message", metavar="FILE",
                        help="Send the message stored in FILE")
    parser.add_argument("--connections", metavar="COUNT",
                        help="Create COUNT connections", default=1, type=int)
    parser.add_argument("--sessions", metavar="COUNT",
                        help="Create COUNT sessions", default=1, type=int)
    parser.add_argument("--links", metavar="COUNT",
                        help="Create COUNT links", default=1, type=int)
    parser.add_argument("--server", action="store_true",
                        help="Operate in server mode")
    
    args = parser.parse_args()

    impl = os.path.join(home, "quiver-{}".format(args.impl))
    work_dir = tempfile.mkdtemp(prefix="quiver-")
    operation = args.operation
    transfers = str(args.transfers)
    connections = args.connections
    sessions = max(args.sessions, args.connections)
    links = max(args.links, sessions)

    if not os.path.exists(impl):
        exit("Error: Can't find '{}'".format(impl))
    
    if args.server:
        mode = "server"
    else:
        mode = "client"

    if "/" in args.url:
        host_port, address = args.url.split("/", 1)
    else:
        host_port, address = "localhost:5672", args.url
    
    command = [
        impl,
        work_dir,
        mode,
        operation,
        host_port,
        address,
        transfers,
    ]

    if mode == "client":
        command += [
            "connections={}".format(connections),
            "sessions={}".format(sessions),
            "links={}".format(links),
        ]

    if operation == "send":
        message_file = args.message
        
        if args.message is None:
            message_file = subprocess.check_output("quiver-message")

            if message_file.endswith("\n"):
                message_file = message_file[:-1]
            
        command.append("message={}".format(message_file))

    print("Calling '{}'".format(" ".join(command)))

    subprocess.check_call(command)

    if operation == "receive":
        report(work_dir)

    print(work_dir)
    #shutil.rmtree(work_dir)
        
def report(work_dir):
    transfers_file = os.path.join(work_dir, "transfers.csv")
    send_times = list()
    receive_times = list()
    latencies = list()
    
    with open(transfers_file, "r") as f:
        for line in f:
            message_id, send_time, receive_time = line.split(",", 2)

            send_time = float(send_time)
            receive_time = float(receive_time)
            latency = receive_time - send_time

            send_times.append(send_time)
            receive_times.append(receive_time)
            latencies.append(latency)

    duration = max(receive_times) - min(send_times)
    transfer_count = len(receive_times)
    transfer_rate = int(round(transfer_count / duration))
    latency_avg = sum(latencies) / transfer_count * 1000
    latency_min = min(latencies) * 1000
    latency_max = max(latencies) * 1000
    latency = "{:.1f}, {:.1f}, {:.1f}".format(latency_min, latency_max,
                                              latency_avg)
            
    print("-" * 80)
    print("{:32} {:24.1f} s".format("Duration:", duration))
    print("{:32} {:24,} transfers".format("Transfer count:", transfer_count))
    print("{:32} {:24,} transfers/s".format("Transfer rate:", transfer_rate))
    print("{:32} {:>24} ms".format("Latency (min, max, avg):", latency))
    print("-" * 80)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass
