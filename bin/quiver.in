#!/usr/bin/python
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals
from __future__ import with_statement

import os
import sys

default_home_dir = os.path.normpath("@quiver_home@")
home_dir = os.environ.get("QUIVER_HOME", default_home_dir)

sys.path.insert(0, os.path.join(home_dir, "python"))

import argparse

from quiver import *

def main():
    description = "Test the performance of AMQP servers and messaging APIs"
    epilog = "operations:\n" \
             "  send                  Send messages\n" \
             "  receive               Receive messages\n" \
             "\n" \
             "addresses:\n" \
             "  [//DOMAIN/]PATH              The default domain is 'localhost:5672'\n" \
             "  //example.net/jobs\n" \
             "  //10.0.0.10:5672/jobs/alpha\n" \
             "  //localhost/q0\n" \
             "  q0\n" \
             "\n" \
             "implementations:\n" \
             "  proton-python\n" \
             "  qpid-messaging-python        Supports client mode only\n" \
             "\n" \
             "example usage:\n" \
             "  $ qdrouterd &                # Start an AMQP server\n" \
             "  $ quiver receive q0 &        # Start receiving\n" \
             "  $ quiver send q0             # Start sending\n" \
             "\n" \

    class Formatter(argparse.ArgumentDefaultsHelpFormatter,
                    argparse.RawDescriptionHelpFormatter):
        pass

    parser = argparse.ArgumentParser(description=description,
                                     epilog=epilog,
                                     formatter_class=Formatter)

    parser.add_argument("operation", metavar="OPERATION",
                        choices=["send", "receive"],
                        help="Either 'send' or 'receive'")
    parser.add_argument("address", metavar="ADDRESS",
                        help="The location of an AMQP node")
    parser.add_argument("-n", "--messages", metavar="COUNT",
                        help="Send or receive COUNT messages",
                        default=100000, type=int)
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="Periodically print status to the console")
    parser.add_argument("--impl", metavar="NAME",
                        help="Use NAME implementation",
                        default="proton-python")
    parser.add_argument("--bytes", metavar="COUNT",
                        help="Send message bodies containing COUNT bytes",
                        default=1000, type=int)
    parser.add_argument("--credit", metavar="COUNT",
                        help="Sustain credit for COUNT incoming transfers",
                        default=100, type=int)
    parser.add_argument("--timeout", metavar="SECONDS",
                        help="Fail after SECONDS without transfers",
                        default=10, type=int)
    parser.add_argument("--server", action="store_true",
                        help="Operate in server mode")
    parser.add_argument("--output", metavar="DIRECTORY",
                        help="Save output files to DIRECTORY")
    parser.add_argument("--quiet", action="store_true",
                        help="Print nothing to the console")
    
    args = parser.parse_args()

    mode = "server" if args.server else "client"
    
    command = Command(home_dir, args.output, args.impl, mode, args.operation,
                      args.address, args.messages, args.bytes, args.credit,
                      args.timeout)

    command.verbose = args.verbose
    command.quiet = args.quiet
    
    command.init()
    
    try:
        command.check()
    except Exception as e:
        exit("Error: {}".format(e))

    command.run()

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass
