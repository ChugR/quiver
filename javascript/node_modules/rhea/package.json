{
  "name": "rhea",
  "version": "0.1.11",
  "description": "reactive AMQP 1.0 library",
  "homepage": "http://github.com/grs/rhea",
  "license": "Apache-2.0",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/grs/rhea.git"
  },
  "dependencies": {
    "debug": ">=0.8.0"
  },
  "devDependencies": {
    "eslint": "",
    "mocha": "",
    "browserify": "",
    "istanbul": ""
  },
  "scripts": {
    "lint": "eslint lib/*.js",
    "test": "mocha",
    "coverage": "istanbul cover _mocha",
    "browserify": "browserify -r rhea -o rhea.js",
    "run-examples": "mocha examples/test_examples.js"
  },
  "keywords": [
    "amqp",
    "messaging"
  ],
  "main": "./lib/container.js",
  "readme": "[![Build Status](https://travis-ci.org/grs/rhea.svg?branch=master)](https://travis-ci.org/grs/rhea)\n\n# rhea\n\nA reactive library for the [AMQP](http://amqp.org/) protocol, for easy\ndevelopment of both clients and servers.\n\n* [Hello World!](#hello-world)\n* [API](#api)\n\n## Hello World!\n\nBrief example of sending and receiving a message through a\nbroker/server listening on port 5672:\n\n```js\nvar container = require('rhea');\ncontainer.on('connection_open', function (context) {\n    context.connection.open_receiver('examples');\n    context.connection.open_sender('examples');\n});\ncontainer.on('message', function (context) {\n    console.log(context.message.body);\n    context.connection.close();\n});\ncontainer.once('sendable', function (context) {\n    context.sender.send({body:'Hello World!'});\n});\ncontainer.connect({'port':5672});\n```\n\noutput:\n```\nHello World!\n```\n## Dependencies\n\n* debug (For simple debug logging - may be replaced in the near\n  term. To enable set e.g. DEBUG=rhea* or DEBUG=rhea:events for more\n  qualified debugging)\n\n## Examples\n\nThere are some examples of using the library under the examples\nfolder. These include:\n\n* [helloworld.js](examples/helloworld.js) - essentially the code above, which sends and receives\n  a single message through a broker\n\n* [direct_helloworld.js](examples/direct_helloworld.js) - an example\n  showing the sending of a single message without the use of a broker,\n  by listening on a port and then openning a connection to itself over\n  which the message is transfered.\n\n* [simple_send.js](examples/simple_send.js) - connects to a specified\n  port then sends a number of messages to a given address\n\n* [simple_recv.js](examples/simple_recv.js) - connects to a specified\n  port then subscribes to receive a number of messages from a given\n  address\n\nThese last two can be used together to demsontrate sending messages\nfrom one process to another, using a broker or similar intermediary to\nwhich they both connect.\n\n* [direct_recv.js](examples/direct_recv.js) - listens on a given port\n  for incoming connections over which it will then receive a number of\n  messages\n\nThe direct_recv.js example can be used in conjunction with the\nsimple_send.js example to demonstrate sending messages between\nprocesses without the use of any intermediary. Note however the the\ndefault port of one or ther other will need to be changed through the\n-p command line option.\n\n* [client.js](examples/client.js) and [server.js](examples/server.js)\n  - A request-response example where the 'client' sends messages to a\n  'server' (or service) which converts them to upper case and sends\n  them back. This demonstrates the use of temporary addresses among\n  other things. Using these two together requires a broker or similar\n  intermediary.\n\n* In durable_subscription, a\n  [subscriber](examples/durable_subscription/subscriber.js) and a\n  [publisher]( examples/durable_subscription/publisher.js)which\n  demonstrate the notion of a durable subscription when used in\n  conjunction with a broker such as ActiveMQ\n\n* In selector a [receiver](examples/selector/recv.js) that uses a\n  selector - a SQL like query string that restricts the set of\n  messages delivered - and an accompanying\n  [sender](examples/selector/send.js)\n\n* In sasl a [sasl client](examples/sasl/simple_sasl_client.js) showing\n  how to authenticate to the service you connect to. This can be used\n  against any broker as well as either of two example servers showing\n  [anonymous](examples/sasl/sasl_anonymous_server.js) and\n  [plain](examples/sasl/sasl_plain_server.js) mechanisms.\n\n* A tls [client](examples/tls/tls_client.js) and\n  [server](examples/tls/tls_server.js) demonstrating connecting (and\n  possibly authenticating) over a tls secured socket.\n\n* A [client](examples/reconnect/client.js) to demonstrate the built in\n  automatic reconnection functionality along with a simple [echo\n  server](examples/reconnect/echo.js) against which it can be run. It\n  can of course also be run against a broker instead (or as well!).\n\n* A rpc [client](examples/rpc/client.js) and\n  [server](example/rpc/server.js) (requires a broker).\n\n* Both [node based](examples/websockets/client.js) and [web\n  based](examples/websockets/client.html) websocket clients along with\n  a [server](examples/websockets/echo.js) which will echo back any\n  requests received. The clients can also be used against a websocket\n  enabled AMQP broker with a queue or topic called 'examples'. The\n  node based scritps require the 'ws' node module to be installed. The\n  browser based example requires a browserified version of the rhea\n  library (this can be created e.g. by calling npm run-script\n  browserify).\n\nTo run the examples you will need the dependencies installed: the\nlibrary itself depends on the 'debug' module, and some of the examples\ndepend on the 'yargs' module for command line option parsing.\n\nThe 'rhea' module itself must also be findable by node. You can do\nthis either by checking out the code from git and setting NODE_PATH to\ninclude the directory to which you do so (i.e. the directory in which\n'a directory named 'rhea' can be found, or you can install the module\nusing npm.\n\nSome of the examples assume an AMQP compatible broker, such as those\noffered by the ActiveMQ or Qpid Apache projects, is running.\n\n## API\n\nThere are four core types of object in the API:\n\n  * <a href=\"#container\">Containers</a>,\n  * <a href=\"#connection\">Connections</a>,\n  * <a href=\"#receiver\">Receivers</a>,\n  * and <a href=\"#sender\">Senders</a>\n\nEach of these inherits all the methods of EventEmitter, allowing\nhandlers for particular events to be attached. Events that are not\nhandled at sender or receiver scope are then propagated up to possibly\nbe handled at connection scope. Events that are not handled at\nconnection scope are then propagated up to possibly be handled at\ncontainer scope.\n\n---------------------------------------------------------------------\n### Container\n\nAn AMQP container from which outgoing connections can be made and/or\nto which incoming connections can be accepted. The module exports a\ndefault instance of a Container which can be used directly. Other\ninstances can be created from that if needed using the\ncreate_container method. A container is identified by the\nid property. By default a uuid is used, but the property\ncan be set to something more specific if desired before making or\naccepting any connections.\n\n#### methods:\n\n##### connect(options)\n\nConnects to the server specified by the host and port supplied in the\noptions and returns a <a href=\"#connection\">Connection</a>.\n\nThe options argument is an object that may contain any of the\nfollowing fields:\n\n  * host\n  * port\n  * username\n  * password\n  * container_id (overrides the container identifier)\n  * reconnect\n    * if true (the default), the library will automatically attempt to\n      reconnect if disconnected\n    * if false, automatic reconnect will be disabled\n    * if it is a numeric value, it is interpreted as the delay between\n      reconnect attempts (in milliseconds)\n    When enabled, reconnect can be further controlled via the\n    following options:\n    * initial_reconnect_delay (in milliseconds)\n    * max_reconnect_delay (in milliseconds)\n    * reconnect_limit (maximum number of reconnect attempts)\n  * connection_details - a function which is specified will be invoked\n    to get the options to use (e.g. this can be used to alternate\n    between a set of different host/port combinations)\n\nIf the transport is TLS, the options may additionally specify a\n'servername' property. This allows the SNI to be controlled separately\nfrom the host option. If servername is not specified, the SNI will\ndefault to the host.\n\n##### listen(options)\n\nStarts a server socket listening for incoming connections on the port\n(and optionally interface) specified in the options.\n\nThe options argument is an object that may contain any of the\nfollowing fields:\n\n  * host\n  * port\n\n##### create_container()\n\nReturns a new container instance. The method takes an options object\nwhich can contain the following field:\n\n  * id\n\nIf no id is specified a new uuid will be generated.\n\n##### generate_uuid()\n\nSimple utility for generating a stringified uuid, useful if you wish\nto specify distinct container ids for different connections.\n\n##### websocket_connect()\n\nReturns a function that can be used to create another function\nsuitable for use as the value of 'connection_details' in a connect\ncall in order to connect over websockets. The function returned here\ntakes a websocket url and optional arguments. The websocket_connect\nmethod itself take the constructor of the WebSocket implementation to\nuse. It has been tested with the implementation in firefox and also\nthat in the node module 'ws'.\n\n##### websocket_accept()\n\nUsed to start handling an incoming websocket connection as an AMQP\nconnection. See the [websocket echo server\nexample](example/websocket/echo.js) for how to use it.\n\n---------------------------------------------------------------------\n### Connection\n\n#### methods:\n\n##### open_receiver(address|options)\n\nEstablishes a link over which messages can be received and returns a\n<a href=\"#receiver\">Receiver</a> representing that link. A receiving\nlink is a subscription, i.e. it expresses a desire to receive\nmessages.\n\nThe argument to this method can either be a simple string indicating\nthe source of messages of interest (e.g. a queue name), or an options\nobject that may contain any of the following fields:\n\n  * source - The source from which messages are received. This can be\n    a simple string address/name or a nested object itself containing\n    the fields:\n    * address\n    * dynamic\n    * expiry_policy\n    * durable\n  * target - The target of a receiving link is the local\n    identifier. It is often not needed, but can be set if it is,\n  * name - The name of the link. This should be unique for the\n    container. If not specified a unqiue name is generated.\n  * prefetch - A 'prefetch' window controlling the flow of messages\n    over this receiver. Defaults to 500 if not specified. A value of 0\n    can be used to turn of automatic flow control and manage it\n    directly.\n  * autoaccept - Whether received messages should be automatically\n    accepted. Defaults to true.\n\nNote: If the link doesn't specify a value for the prefetch and\nautoaccept options, the connection options are consulted followed by\nthe container options. The default is used only if an option is not\nspecified at any level.\n\n##### open_sender(address|options)\n\nEstablishes a link over which messages can be sent and returns a <a\nhref=\"#sender\">Sender</a> representing that link. A sending link is an\nanalogous concept to a subscription for outgoing rather than incoming\nmessages. I.e. it expresses a desire to send messages.\n\nThe argument to this method can either be a simple string indicating\nthe target for messages of interest (e.g. a queue name), or an options\nobject that may contain any of the following fields:\n\n  * target - The target to which messages are sent. This can be a\n    simple string address/name or a nested object itself containing\n    the fields:\n    * address\n    * dynamic\n    * expiry_policy\n    * durable\n  * source - The source of a sending link is the local identifier. It\n    is usually not needed, but can be set if it is,\n  * name - The name of the link. This should be unique for the\n    container. If not specified a unqiue name is generated.\n  * autosettle - Whether sent messages should be automatically\n    settled once the peer settles them. Defaults to true.\n\nNote: If the link doesn't specify a value for the autosettle option,\nthe connection options are consulted followed by the container\noptions. The default is used only if an option is not specified at any\nlevel.\n\n##### send(message)\n\nSends the specified message over the default sender, which is a\nsending link whose target address is null. The use of this method\ndepends on the peer supporting so-called 'anonymous relay' semantics,\nwhich most AMQP 1.0 brokers do. The message should contain a\nproperties map with a 'to' field set to the intended destination.\n\n##### close()\n\nCloses a connection (may take an error object which is an object\nthat consists of condition and description fields).\n\n##### is_open()/is_closed()\n\nProvide information about the connection status. If it's opened or closed.\n\n#### events:\n\n##### connection_open\n\nRaised when the remote peer indicates the connection is open.\n\n##### connection_close\n\nRaised when the remote peer indicates the connection is closed.\n\n##### disconnected\n\nRaised when the underlying tcp connection is lost.\n\n---------------------------------------------------------------------\n### Receiver\n\n#### methods:\n\n##### close()\n\nCloses a receiving link (i.e. cancels the subscription). (May take an error object which is an object\nthat consists of condition and description fields).\n\n##### detach()\n\nDetaches a link without closing it. For durable subscriptions this\nmeans the subscription is inactive, but not cancelled.\n\n##### add_credit(n)\n\nBy default, receivers have a prefetch window that is moved\nautomatically by the library. However if desired the application can\nset the prefecth to zero and manage credit itself. Each invocation of\nadd_credit() method issues credit for a further 'n' messages to be\nsent by the peer over this receiving link. [Note: flow()is an alias\nfor add_credit()]\n\n##### credit()\n\nReturns the amount of outstanding credit that has been issued.\n\n#### events:\n\n##### message\n\nRaised when a message is received.\n\n##### receiver_open\n\nRaised when the remote peer indicates the link is open (i.e. attached\nin AMQP parlance).\n\n##### receiver_close\n\nRaised when the remote peer indicates the link is closed.\n\n---------------------------------------------------------------------\n### Sender\n\n#### methods:\n\n##### send(msg)\n\nSends a message. A message is an object that may contain the following fields:\n\n  * header, an object which has the following fields:\n    * durable\n    * first_acquirer\n    * priority\n    * ttl\n    * delivery_count\n  * properties, an object which has the following fields:\n    * reply_to\n    * to\n    * subject\n    * content_type\n    * content_encoding\n    * group_id\n    * id\n    * correlation_id\n  * application properties, an object/map which can take arbitrary, application defined named values\n  * body, which can be either a string, an object or a buffer\n\nThe header, properties and application_properties can be set on the\nmessage itself, i.e. the nesting is not necessary (it reflects the\nAMQP specification however). So\ne.g. {subject:'abc',colour:'green',body:'foo'} is equivalent to\n{properties:{subject:'abc'},application_properties:{colour:'green'},body:'foo'}\n\n##### close()\n\nCloses a sending link (may take an error object which is an object\nthat consists of condition and description fields).\n\n##### detach()\n\nDetaches a link without closing it.\n\n##### sendable()\n\nReturns true if the sender has available credits for sending a message. Otherwise it returns false.\n\n#### events:\n\n##### sendable\n\nRaised when the sender has sufficient credit to be able to transmit\nmessages to its peer.\n\n##### accepted\n\nRaised when a sent message is accepted by the peer.\n\n##### released\n\nRaised when a sent message is released by the peer.\n\n##### rejected\n\nRaised when a sent message is rejected by the peer.\n\n##### sender_open\n\nRaised when the remote peer indicates the link is open (i.e. attached\nin AMQP parlance).\n\n##### sender_close\n\nRaised when the remote peer indicates the link is closed.\n",
  "readmeFilename": "README.md",
  "gitHead": "6b761e8cce86ebf2d770b4745e953a7c892da4a2",
  "bugs": {
    "url": "https://github.com/grs/rhea/issues"
  },
  "_id": "rhea@0.1.11",
  "_shasum": "c2d3ae7698afaea33bb2e2046d42f2663708a1ce",
  "_from": "rhea@0.1.11"
}
